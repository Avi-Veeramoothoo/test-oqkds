{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"OpenQKDSecurity Software Github Code Release: Version 2.0 Research Group: Optical Quantum Communication Theory Group University of Waterloo: Institute for Quantum Computing About OpenQKDSecurity is a software package based in MATLAB that allows users to calculate key rates for quantum key distribution (QKD) protocols using the Winick et al. framework ( arXiv ). It is extensible, allowing for user-defined protocols to be implemented, and modular, allowing for users to change specific aspects of a protocol. Our software can be used to interface with experimental data, demonstrate the theoretical scalability of protocols in various conditions, and optimize parameters to maximize key rate. Its modular structure helps break down the colossal task of calculating key rates into small areas that require only domain specific knowledge. Therefore, no single person must be an expert in all areas. We break down a numerical QKD security proof into a preset and 5 different modules described below: Layer Difficulty Audience Description Preset Basic to Intermediate Everyone The Preset sets up a QKD protocol by defining parameters, options and modules to use. Use cases range from simply picking a predefined preset and tweaking parameters to selection of modules and technical options. Description Intermediate Users with intermediate knowledge of QKD protocols, including proof techniques. Using the initial parameters given in the preset, a description module constructs complete description of a QKD protocol. Measurement observables, announcement structure, and the key map are typically defined on this layer. Channel Intermediate Users with intermediate to advanced knowledge of channel simulation or computing key rate from experimental data. The channel module produces expectation values or observed frequencies from Alice and Bob's measurements on their exchanged states. These values can be obtained from numerical simulation or imported from an external source. Experimental data should also be loaded in this layer. Key Rate Advanced Users with advanced knowledge of numerical proof techniques in QKD. This layer is responsible for determining the key rate of a class of protocols based on the given parameters. Proof techniques such as decoy state analysis and squashing should be implemented in this layer. This layer is also responsible for processing input to be forwarded to the math solver. Math Solver Advanced Users with advanced knowledge of convex optimization. Calculates a strict lower bound on the quantum relative entropy between the key and Eve via convex optimization. Optimizer Advanced Users with knowledge of general optimization techniques with the intent to minimize the number of calls to the objective function needed to find the global maximum. Routines to perform unstructured optimization on selected parameters, using the key rate as the objective. This layer is given a wrapped version of the protocol with options modified to reduce precision but decrease calculation time. Once parameters, modules, and options are packaged into a preset file, running a numerical key rate calculation is as simple as: % Qubit BB84 prepare and measure. We use Schmidt decomposition to reduce % the dimension of Alice's state for enhanced speed and stability. qkdInput = BasicBB84Alice2DPreset(); %run the QKDSolver with this input results = MainIteration(qkdInput); %save the results and preset to a file. save(\"BasicBB84Alice2DResults.mat\",\"results\",\"qkdInput\"); %% plot the result QKDPlot.simple1DPlot(qkdInput,results) Further documentation and examples may be found in the included user guide PDF. Current Status Currently in this version of the software, we provide the following example protocols: Qubit BB84 with no loss, where Alice is 4-dimensional Qubit BB84 with no loss, where Alice has been reduced to two dimensions (this reduction is used in all of the following protocols) Qubit BB84 with loss Qubit BB84 with a finite number of signals sent Weak coherent pulse-based BB84 with decoy-state analysis We also provide two math solver modules: FW2StepSolver, which uses a Frank-Wolfe iteration algorithm followed by a linearization and conversion to dual in order to calculate a reliable lower bound on the quantum relative entropy. This is based on work done by our group published at https://arxiv.org/abs/1710.05511v2. FRGNSolver (requires the ZGNQKD solver), which uses facial reduction and a Gauss-Newton method to simplify and solve the SDP to arrive at quantum relative entropy. This solver was written by members of Henry Wolkowicz's group at the University of Waterloo and is published at https://arxiv.org/abs/2104.03847v2. Note that this solver can only handle strict equality constraints at the moment. In the future, we plan to add more protocols. We also welcome custom-defined protocols and solver modules. Citing If you use Open QKD Security in research, please cite our software and write in your document something like: To calculate the key rate for protocol \"X\" we used the Open QKD Security package[#]. Here is a bibtex entry you can use: @software{burniston_2024_14262569, author = {Burniston, John and Wang, Wenyuan and Kamin, Lars and Lin, Jie and Coles, Patrick and Metodiev, Eric and George, Ian and Li, Nicky Kai Hong and Fang, Kun and Chemtov, Max and Zhang, Yanbao and B\u00f6hm, Christopher and Winick, Adam and van Himbeeck, Thomas and Johnstun, Scott and Nahar, Shlok and Tupkary, Devashish and Pan, Shihong and Wang, Zhiyao and Corrigan, Aodhan and Kanitschar, Florian and Gracie, Laura and Gu, Shouzhen and Mathur, Natansh and Upadhyaya, Twesh and Lutkenhaus, Norbert}, title = {Open {QKD} {S}ecurity: {V}ersion 2.0.2}, month = dec, year = 2024, publisher = {Zenodo}, version = {v2.0.2}, doi = {10.5281/zenodo.14262569}, url = {https://doi.org/10.5281/zenodo.14262569} swhid = {swh:1:dir:ce63165f716a15a425fbadc208e27934cc66be10 ;origin=https://doi.org/10.5281/zenodo.14262568;vi sit=swh:1:snp:ea6ece4519d009abf5ae6b7c084f97ba9d3f 14c2;anchor=swh:1:rel:54e7860c1d1e613f2e7a075653d1 2fa44f1226fa;path=/ }, } Contributing If you would like to contribute, please contact Professor L\u00fctkenhaus at lutkenhaus.office@uwaterloo.ca. License OpenQKDSecurity is licensed under the MIT license. See the LICENSE file for details. Acknowledgements This work has been performed at the Institute for Quantum Computing (IQC), which is supported by Innovation, Science and Economic Development (ISED) Canada. This research has been supported by NSERC Collaborative Research and Development (CRD) Program and Discovery Grants Program. Financial support for this project has been partially provided by Huawei Technologies Canada Co., Ltd.","title":"Home"},{"location":"#openqkdsecurity-software","text":"Github Code Release: Version 2.0 Research Group: Optical Quantum Communication Theory Group University of Waterloo: Institute for Quantum Computing","title":"OpenQKDSecurity Software"},{"location":"#about","text":"OpenQKDSecurity is a software package based in MATLAB that allows users to calculate key rates for quantum key distribution (QKD) protocols using the Winick et al. framework ( arXiv ). It is extensible, allowing for user-defined protocols to be implemented, and modular, allowing for users to change specific aspects of a protocol. Our software can be used to interface with experimental data, demonstrate the theoretical scalability of protocols in various conditions, and optimize parameters to maximize key rate. Its modular structure helps break down the colossal task of calculating key rates into small areas that require only domain specific knowledge. Therefore, no single person must be an expert in all areas. We break down a numerical QKD security proof into a preset and 5 different modules described below: Layer Difficulty Audience Description Preset Basic to Intermediate Everyone The Preset sets up a QKD protocol by defining parameters, options and modules to use. Use cases range from simply picking a predefined preset and tweaking parameters to selection of modules and technical options. Description Intermediate Users with intermediate knowledge of QKD protocols, including proof techniques. Using the initial parameters given in the preset, a description module constructs complete description of a QKD protocol. Measurement observables, announcement structure, and the key map are typically defined on this layer. Channel Intermediate Users with intermediate to advanced knowledge of channel simulation or computing key rate from experimental data. The channel module produces expectation values or observed frequencies from Alice and Bob's measurements on their exchanged states. These values can be obtained from numerical simulation or imported from an external source. Experimental data should also be loaded in this layer. Key Rate Advanced Users with advanced knowledge of numerical proof techniques in QKD. This layer is responsible for determining the key rate of a class of protocols based on the given parameters. Proof techniques such as decoy state analysis and squashing should be implemented in this layer. This layer is also responsible for processing input to be forwarded to the math solver. Math Solver Advanced Users with advanced knowledge of convex optimization. Calculates a strict lower bound on the quantum relative entropy between the key and Eve via convex optimization. Optimizer Advanced Users with knowledge of general optimization techniques with the intent to minimize the number of calls to the objective function needed to find the global maximum. Routines to perform unstructured optimization on selected parameters, using the key rate as the objective. This layer is given a wrapped version of the protocol with options modified to reduce precision but decrease calculation time. Once parameters, modules, and options are packaged into a preset file, running a numerical key rate calculation is as simple as: % Qubit BB84 prepare and measure. We use Schmidt decomposition to reduce % the dimension of Alice's state for enhanced speed and stability. qkdInput = BasicBB84Alice2DPreset(); %run the QKDSolver with this input results = MainIteration(qkdInput); %save the results and preset to a file. save(\"BasicBB84Alice2DResults.mat\",\"results\",\"qkdInput\"); %% plot the result QKDPlot.simple1DPlot(qkdInput,results) Further documentation and examples may be found in the included user guide PDF.","title":"About"},{"location":"#current-status","text":"Currently in this version of the software, we provide the following example protocols: Qubit BB84 with no loss, where Alice is 4-dimensional Qubit BB84 with no loss, where Alice has been reduced to two dimensions (this reduction is used in all of the following protocols) Qubit BB84 with loss Qubit BB84 with a finite number of signals sent Weak coherent pulse-based BB84 with decoy-state analysis We also provide two math solver modules: FW2StepSolver, which uses a Frank-Wolfe iteration algorithm followed by a linearization and conversion to dual in order to calculate a reliable lower bound on the quantum relative entropy. This is based on work done by our group published at https://arxiv.org/abs/1710.05511v2. FRGNSolver (requires the ZGNQKD solver), which uses facial reduction and a Gauss-Newton method to simplify and solve the SDP to arrive at quantum relative entropy. This solver was written by members of Henry Wolkowicz's group at the University of Waterloo and is published at https://arxiv.org/abs/2104.03847v2. Note that this solver can only handle strict equality constraints at the moment. In the future, we plan to add more protocols. We also welcome custom-defined protocols and solver modules.","title":"Current Status"},{"location":"#citing","text":"If you use Open QKD Security in research, please cite our software and write in your document something like: To calculate the key rate for protocol \"X\" we used the Open QKD Security package[#]. Here is a bibtex entry you can use: @software{burniston_2024_14262569, author = {Burniston, John and Wang, Wenyuan and Kamin, Lars and Lin, Jie and Coles, Patrick and Metodiev, Eric and George, Ian and Li, Nicky Kai Hong and Fang, Kun and Chemtov, Max and Zhang, Yanbao and B\u00f6hm, Christopher and Winick, Adam and van Himbeeck, Thomas and Johnstun, Scott and Nahar, Shlok and Tupkary, Devashish and Pan, Shihong and Wang, Zhiyao and Corrigan, Aodhan and Kanitschar, Florian and Gracie, Laura and Gu, Shouzhen and Mathur, Natansh and Upadhyaya, Twesh and Lutkenhaus, Norbert}, title = {Open {QKD} {S}ecurity: {V}ersion 2.0.2}, month = dec, year = 2024, publisher = {Zenodo}, version = {v2.0.2}, doi = {10.5281/zenodo.14262569}, url = {https://doi.org/10.5281/zenodo.14262569} swhid = {swh:1:dir:ce63165f716a15a425fbadc208e27934cc66be10 ;origin=https://doi.org/10.5281/zenodo.14262568;vi sit=swh:1:snp:ea6ece4519d009abf5ae6b7c084f97ba9d3f 14c2;anchor=swh:1:rel:54e7860c1d1e613f2e7a075653d1 2fa44f1226fa;path=/ }, }","title":"Citing"},{"location":"#contributing","text":"If you would like to contribute, please contact Professor L\u00fctkenhaus at lutkenhaus.office@uwaterloo.ca.","title":"Contributing"},{"location":"#license","text":"OpenQKDSecurity is licensed under the MIT license. See the LICENSE file for details.","title":"License"},{"location":"#acknowledgements","text":"This work has been performed at the Institute for Quantum Computing (IQC), which is supported by Innovation, Science and Economic Development (ISED) Canada. This research has been supported by NSERC Collaborative Research and Development (CRD) Program and Discovery Grants Program. Financial support for this project has been partially provided by Huawei Technologies Canada Co., Ltd.","title":"Acknowledgements"},{"location":"announcements/","text":"","title":"Announcements"},{"location":"contribute/","text":"Contribute If you would like to contribute, please contact Professor L\u00fctkenhaus at lutkenhaus.office@uwaterloo.ca. To add a page to this website: Write the content using Markdown language and upload the 'newpage.md' under the path website/docs/ Ensure that you also add the page in the navigation menu and by filling website/docs/mkdocs.yml under the 'nav' heading.","title":"Contribute"},{"location":"contribute/#contribute","text":"If you would like to contribute, please contact Professor L\u00fctkenhaus at lutkenhaus.office@uwaterloo.ca. To add a page to this website: Write the content using Markdown language and upload the 'newpage.md' under the path website/docs/ Ensure that you also add the page in the navigation menu and by filling website/docs/mkdocs.yml under the 'nav' heading.","title":"Contribute"},{"location":"deployment/","text":"Deployment You can run OpenQKDSecurity using 3 methods. Each is a solution to a different use case, so use the pros/cons list to evaluate your situation and pick the best method for you. The tradeoffs usually consider the computational power, ease of access and dependency conflicts. Local desktop (Recommended for regular use) If you have followed the installation process, then you can open your Matlab on your desktop and navigate to the path of the OpenQKDSecurity folder to run a local instance of the project. PROS The local instance works with all 4 dependencies, assuming you install MOSEK and require it. CONS The packages may require different versions, that are in conflict with current versions installed on your desktop needed to run other projects. Online IDE You can use OpenQKDSecurity from an online IDE without requiring any installation. Visit this website and login using your Matlab Online account credentials. Run installDependencies.m and addPath.m before using the IDE. PROS The online IDE requires no installation on the user's part. It's convenient for temporary usage from any device with internet access. CONS It does not have the MOSEK package (4th dependency) installed due to requiring an individual user license -- although MOSEK is optional for OpenQKDSecurity. Packaged container OpenQKDSecurity packaged as a container is a solution for dependency conflicts of Matlab packages. You can also spin up multiple instances of the container using the script we provide. Ensure that you have Docker Engine and Python installed. Download the script and run py OpenQKDSecurity.py --install to download OpenQKDSecurity and the first 3 dependencies. Run py OpenQKDSecurity.py --spinup to launch a container and py OpenQKDSecurity.py --spindown to kill it after use if no longer needed. Login using your Matlab Online account credentials, and for the first time run installDependencies.m and addPath.m . PROS Containerized OpenQKDSecurity allows you to run the project independent of the versions of Matlab and dependencies installed on your local desktop. For example, OpenQKDSecurity requires Matlab >= 2020b and QETLAB > v0.9. You can still run your other projects requiring lower versions of Matlab/QETLAB while running OpenQKDSecurity as a self-contained package with the higher versions. You do need to resolve dependency conflicts. The packaged container is lightweight in terms of memory compared to the local desktop (500MB vs ~4.5GB). CONS Packaged container is a bit more advanced, requiring knowledge of the command line to run a python script that will launch the container. It does not have the MOSEK package (4th dependency) installed due to requiring an individual user license -- although MOSEK is optional for OpenQKDSecurity.","title":"Deployment"},{"location":"deployment/#deployment","text":"You can run OpenQKDSecurity using 3 methods. Each is a solution to a different use case, so use the pros/cons list to evaluate your situation and pick the best method for you. The tradeoffs usually consider the computational power, ease of access and dependency conflicts.","title":"Deployment"},{"location":"deployment/#local-desktop-recommended-for-regular-use","text":"If you have followed the installation process, then you can open your Matlab on your desktop and navigate to the path of the OpenQKDSecurity folder to run a local instance of the project. PROS The local instance works with all 4 dependencies, assuming you install MOSEK and require it. CONS The packages may require different versions, that are in conflict with current versions installed on your desktop needed to run other projects.","title":"Local desktop (Recommended for regular use)"},{"location":"deployment/#online-ide","text":"You can use OpenQKDSecurity from an online IDE without requiring any installation. Visit this website and login using your Matlab Online account credentials. Run installDependencies.m and addPath.m before using the IDE. PROS The online IDE requires no installation on the user's part. It's convenient for temporary usage from any device with internet access. CONS It does not have the MOSEK package (4th dependency) installed due to requiring an individual user license -- although MOSEK is optional for OpenQKDSecurity.","title":"Online IDE"},{"location":"deployment/#packaged-container","text":"OpenQKDSecurity packaged as a container is a solution for dependency conflicts of Matlab packages. You can also spin up multiple instances of the container using the script we provide. Ensure that you have Docker Engine and Python installed. Download the script and run py OpenQKDSecurity.py --install to download OpenQKDSecurity and the first 3 dependencies. Run py OpenQKDSecurity.py --spinup to launch a container and py OpenQKDSecurity.py --spindown to kill it after use if no longer needed. Login using your Matlab Online account credentials, and for the first time run installDependencies.m and addPath.m . PROS Containerized OpenQKDSecurity allows you to run the project independent of the versions of Matlab and dependencies installed on your local desktop. For example, OpenQKDSecurity requires Matlab >= 2020b and QETLAB > v0.9. You can still run your other projects requiring lower versions of Matlab/QETLAB while running OpenQKDSecurity as a self-contained package with the higher versions. You do need to resolve dependency conflicts. The packaged container is lightweight in terms of memory compared to the local desktop (500MB vs ~4.5GB). CONS Packaged container is a bit more advanced, requiring knowledge of the command line to run a python script that will launch the container. It does not have the MOSEK package (4th dependency) installed due to requiring an individual user license -- although MOSEK is optional for OpenQKDSecurity.","title":"Packaged container"},{"location":"installation/","text":"Installation Prerequisites Before installing the software, ensure you have the latest version of MATLAB installed on your machine. Our software requires at least version 2020b for full functionality, but installing the latest version is preferable. OpenQKDSecurity package To install the OpenQKDSecurity package, download the repository on GitHub as a zip file and unzip it to a preferred directory. This can be done on the main page of the repository by pressing the green \u201cCode\u201d button at the top of the page and then selecting \"Download ZIP\" . Dependencies Our software has the following dependencies for its default settings: CVX v2.2, a library for solving convex optimization problems in MATLAB. QETLAB above v0.9, a MATLAB toolbox for operations involving quantum channels and entanglement. Note that you cannot use the version from their website as it has bugs associated with implementing Choi matrices. You must use their latest copy on GitHub . At the time of writing, this means downloading their code with the green \"code\" button and not the v0.9 release. ZGNQKD solver (optional), an alternative to our Frank-Wolfe solver for quantum relative entropy. Currently, it only supports equality constraints. Download the zip and the \"Solver\" folder and sub-folders to your path. MOSEK (optional), a more advanced semidefinite programming (SDP) solver than the default (SDPT3) used in CVX. Note that the MOSEK solver can be downloaded together with CVX, but requires a separate license to use. See this page for more information. To install CVX, QETLAB and ZGNQKD, you can run installDependencies.m to automate their installation. For MOSEK, you need to install it manually to input its license. Alternatively, you can install all 4 manually. Please refer to the documentation of each of these software packages for installation instructions. Saving installation Next, ensure that our software and the above dependencies are on your MATLAB path. To place a folder on your path, navigate to it in MATLAB, then right-click and select \"Add to Path > Selected folder and Subfolders\". Make sure you do this for OpenQKDSecurity, QETLAB, and CVX. We also recommend you run \"cvx_setup\" to check if CVX is properly configured and which solvers are available. Before you close MATLAB, go to \"Home > Environment > Set Path\" and click \"save\" at the bottom. If you don't, then you have to add everything to your path each time you restart MATLAB. IMPORTANT We strongly encourage you to run testInstall.m at this point to check for basic installation issues.","title":"Installation"},{"location":"installation/#installation","text":"","title":"Installation"},{"location":"installation/#prerequisites","text":"Before installing the software, ensure you have the latest version of MATLAB installed on your machine. Our software requires at least version 2020b for full functionality, but installing the latest version is preferable.","title":"Prerequisites"},{"location":"installation/#openqkdsecurity-package","text":"To install the OpenQKDSecurity package, download the repository on GitHub as a zip file and unzip it to a preferred directory. This can be done on the main page of the repository by pressing the green \u201cCode\u201d button at the top of the page and then selecting \"Download ZIP\" .","title":"OpenQKDSecurity package"},{"location":"installation/#dependencies","text":"Our software has the following dependencies for its default settings: CVX v2.2, a library for solving convex optimization problems in MATLAB. QETLAB above v0.9, a MATLAB toolbox for operations involving quantum channels and entanglement. Note that you cannot use the version from their website as it has bugs associated with implementing Choi matrices. You must use their latest copy on GitHub . At the time of writing, this means downloading their code with the green \"code\" button and not the v0.9 release. ZGNQKD solver (optional), an alternative to our Frank-Wolfe solver for quantum relative entropy. Currently, it only supports equality constraints. Download the zip and the \"Solver\" folder and sub-folders to your path. MOSEK (optional), a more advanced semidefinite programming (SDP) solver than the default (SDPT3) used in CVX. Note that the MOSEK solver can be downloaded together with CVX, but requires a separate license to use. See this page for more information. To install CVX, QETLAB and ZGNQKD, you can run installDependencies.m to automate their installation. For MOSEK, you need to install it manually to input its license. Alternatively, you can install all 4 manually. Please refer to the documentation of each of these software packages for installation instructions.","title":"Dependencies"},{"location":"installation/#saving-installation","text":"Next, ensure that our software and the above dependencies are on your MATLAB path. To place a folder on your path, navigate to it in MATLAB, then right-click and select \"Add to Path > Selected folder and Subfolders\". Make sure you do this for OpenQKDSecurity, QETLAB, and CVX. We also recommend you run \"cvx_setup\" to check if CVX is properly configured and which solvers are available. Before you close MATLAB, go to \"Home > Environment > Set Path\" and click \"save\" at the bottom. If you don't, then you have to add everything to your path each time you restart MATLAB. IMPORTANT We strongly encourage you to run testInstall.m at this point to check for basic installation issues.","title":"Saving installation"},{"location":"newpage/","text":"This is a new page I'm creating using markdown language (similar to the readme.md files on github).","title":"New Page"},{"location":"research_code/","text":"","title":"Code of Research Papers"},{"location":"user_guide/","text":"User Guide Download PDF","title":"User Guide"},{"location":"user_guide/#user-guide","text":"Download PDF","title":"User Guide"}]}